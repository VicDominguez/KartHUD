/**
 * Impelementamos el cifrado de Vigenere
 * @author Victor Manuel Dominguez Rivas y Juan Luis Moreno Sancho
 */
package es.upm.karthud.malware

import java.lang.StringBuilder
import java.util.Locale

object Vigenere
{
    //los char de kotlin son unicode
    private const val NUMBER_OF_LETTERS = 26
    private const val NUMBER_OF_DIGITS = 10

    /**
     * Codifica únicamente las letras y los numeros, convirtiendo tanto en el texto
     * como en la clave las minúsculas a mayúsculas
     * @see decrypt
     */
    fun encrypt(message: String, key: String) : String
    {
        val messageInChars = message.uppercase(Locale.getDefault()).toCharArray()
        val keyInChars = key.uppercase(Locale.getDefault()).toCharArray()
        val keyLength = keyInChars.size

        var actualMessageChar : Char
        var actualKeyChar : Char
        var resultChar : Char

        val sb = StringBuilder("")

        for(index in messageInChars.indices)
        {
            //solo convertimos las letras mayusculas y los digitos
            actualMessageChar = messageInChars[index]
            actualKeyChar = keyInChars[index % keyLength]
            if (actualMessageChar in 'A'..'Z')
                //cogemos cada char y le quitamos el valor de 'A' para obtener el desplazamiento.
                // Con esto sumamos los 2 modulo numero letras y la convertimos a un char de nuevo
                resultChar = (((actualMessageChar.code - 'A'.code + actualKeyChar.code - 'A'.code)
                        % NUMBER_OF_LETTERS) + 'A'.code).toChar()
            else if (actualMessageChar in '0'..'9')
                //lo mismo pero con 0 como base
                resultChar = (((actualMessageChar.code - '0'.code + actualKeyChar.code - '0'.code)
                        % NUMBER_OF_DIGITS) + '0'.code).toChar()
            else
                resultChar = actualMessageChar
            sb.append(resultChar)
        }
        return sb.toString()
    }

    /**
     * Decodifica únicamente las letras, devolviendo el string en mayúsculas y tomando la clave
     * también en mayúsculas
     * @see decrypt
     */
    fun decrypt(message: String, key: String) : String
    {
        val messageInChars = message.uppercase(Locale.getDefault()).toCharArray()
        val keyInChars = key.uppercase(Locale.getDefault()).toCharArray()
        val keyLength = keyInChars.size

        var actualMessageChar : Char
        var actualKeyChar : Char
        var resultChar : Char

        val sb = StringBuilder("")

        for(index in messageInChars.indices)
        {
            //solo convertimos las letras mayusculas y minusculas de ascii
            actualMessageChar = messageInChars[index]
            actualKeyChar = keyInChars[index % keyLength]
            if (actualMessageChar in 'A'..'Z')
            //restamos los dos char y tenemos el desplazamiento. Le hacemos el modulo y
            // ese desplazamiento lo pasamos a char
                resultChar = (((actualMessageChar.code - actualKeyChar.code)
                        % NUMBER_OF_LETTERS) + 'A'.code).toChar()
            else if (actualMessageChar in '0'..'9')
            //lo mismo pero con 0 como base
                resultChar = (((actualMessageChar.code - actualKeyChar.code)
                        % NUMBER_OF_DIGITS) + '0'.code).toChar()
            else
                resultChar = actualMessageChar
            sb.append(resultChar)
        }
        return sb.toString()
    }
}